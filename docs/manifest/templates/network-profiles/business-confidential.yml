# =====================================================================
# üç£ Business Confidential Network Profile  
# Purpose: Segmented network configuration for moderate security isolation
# Privacy Level: Moderate - suitable for business data requiring basic protection
# Use Cases: Business applications, internal tools, customer-facing services
# =====================================================================

# PHILOSOPHY:
# The business confidential profile implements a three-tier network architecture
# that balances security with operational simplicity. This approach follows the
# principle of "defense in depth" by creating network boundaries between different
# types of services while maintaining reasonable complexity for business teams.

# SECURITY MODEL:
# - Frontend services (user-facing) have limited access to backend systems
# - Backend services (processing) cannot directly access data storage
# - Data services (storage) are isolated from direct external access
# - Cross-tier communication is controlled but not overly restrictive

networks:
  # ===================================================================
  # FRONTEND NETWORK - User-facing services and reverse proxies
  # Services: Web UIs, API gateways, load balancers, authentication
  # ===================================================================
  sushi_frontend:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.enable_icc: "true"
      com.docker.network.bridge.enable_ip_masquerade: "true"
      # Enable external connectivity for user access
      com.docker.network.bridge.host_binding_ipv4: "0.0.0.0"
    ipam:
      driver: default
      config:
        - subnet: "172.21.0.0/24"
          gateway: "172.21.0.1"
          ip_range: "172.21.0.0/26"  # .1-.63 for frontend services
    labels:
      - "sushi.kitchen.network.profile=business_confidential"
      - "sushi.kitchen.network.tier=frontend" 
      - "sushi.kitchen.network.access=external"
      - "sushi.kitchen.network.purpose=user_interface"
    
  # ===================================================================
  # BACKEND NETWORK - Processing services and business logic
  # Services: AI inference, workflow engines, API services, middleware
  # ===================================================================
  sushi_backend:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.enable_icc: "true"
      com.docker.network.bridge.enable_ip_masquerade: "true"
      # No direct external access - internal only
      com.docker.network.bridge.host_binding_ipv4: "127.0.0.1"
    ipam:
      driver: default
      config:
        - subnet: "172.22.0.0/24"
          gateway: "172.22.0.1"
          ip_range: "172.22.0.0/26"  # .1-.63 for backend services
    internal: false  # Allow outbound for model downloads, API calls
    labels:
      - "sushi.kitchen.network.profile=business_confidential"
      - "sushi.kitchen.network.tier=backend"
      - "sushi.kitchen.network.access=internal"
      - "sushi.kitchen.network.purpose=processing"
  
  # ===================================================================
  # DATA NETWORK - Storage and persistence services
  # Services: Databases, vector stores, object storage, caches
  # ===================================================================  
  sushi_data:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.enable_icc: "true"
      com.docker.network.bridge.enable_ip_masquerade: "true"
      # Completely internal - no external access
      com.docker.network.bridge.host_binding_ipv4: "127.0.0.1"
    ipam:
      driver: default
      config:
        - subnet: "172.23.0.0/24"
          gateway: "172.23.0.1"
          ip_range: "172.23.0.0/26"  # .1-.63 for data services
    internal: true  # No outbound access for security
    labels:
      - "sushi.kitchen.network.profile=business_confidential"
      - "sushi.kitchen.network.tier=data"
      - "sushi.kitchen.network.access=none"
      - "sushi.kitchen.network.purpose=storage"

# =====================================================================
# SERVICE NETWORK ASSIGNMENTS
# How different types of services get assigned to network tiers
# =====================================================================

# Network assignment logic based on service characteristics:
service_network_assignments:
  
  # FRONTEND TIER - Services that need external access
  frontend_services:
    networks:
      - sushi_frontend
      - sushi_backend  # Can also access backend for API calls
    service_types:
      - "Web UIs (AnythingLLM, Grafana, etc.)"
      - "Reverse proxies (Caddy, Nginx)"
      - "Authentication services (Authentik)"
      - "API gateways and load balancers"
      - "Documentation sites (Docusaurus)"
    example_services:
      - "hosomaki.caddy"
      - "hosomaki.anythingllm" 
      - "gunkanmaki.authentik"
      - "inari.grafana"
      - "sashimi.docusaurus"
      
  # BACKEND TIER - Processing and business logic  
  backend_services:
    networks:
      - sushi_backend
      - sushi_data    # Can access data layer for storage needs
    service_types:
      - "AI inference engines (Ollama, vLLM)"
      - "Workflow orchestrators (n8n)"
      - "Processing services (Whisper, ComfyUI)"
      - "API middleware and business logic"
      - "Monitoring collectors (Prometheus)"
    example_services:
      - "hosomaki.ollama"
      - "hosomaki.n8n"
      - "temaki.whisper"
      - "uramaki.comfyui"
      - "inari.prometheus"
      
  # DATA TIER - Storage and persistence
  data_services:
    networks:
      - sushi_data    # Only data network access
    service_types:
      - "Databases (PostgreSQL, MySQL)"
      - "Vector databases (Qdrant, Weaviate)"
      - "Caches (Redis, Valkey)"
      - "Object storage (MinIO)"
      - "Search engines (Elasticsearch)"
    example_services:
      - "futomaki.postgresql"
      - "futomaki.qdrant"
      - "futomaki.redis"
      - "futomaki.minio"

# =====================================================================
# INTER-TIER COMMUNICATION PATTERNS
# How services communicate across network boundaries
# =====================================================================

communication_patterns:
  
  # Frontend to Backend Communication:
  frontend_to_backend:
    description: "User interfaces calling AI services and APIs"
    examples:
      - "AnythingLLM ‚Üí Ollama for LLM inference"
      - "Grafana ‚Üí Prometheus for metrics data"
      - "Web UI ‚Üí n8n for workflow management"
    connection_method: "HTTP/HTTPS over backend network"
    security_considerations:
      - "All API calls should use proper authentication"
      - "Consider rate limiting to prevent abuse"
      - "Log API calls for audit purposes"
  
  # Backend to Data Communication:
  backend_to_data:
    description: "Processing services accessing storage systems"
    examples:
      - "Ollama ‚Üí PostgreSQL for session storage"
      - "n8n ‚Üí Redis for job queuing"
      - "Prometheus ‚Üí its own storage volumes"
    connection_method: "Native protocols over data network"
    security_considerations:
      - "Use strong database passwords"
      - "Implement connection pooling"
      - "Monitor for unusual access patterns"
  
  # Cross-tier restrictions:
  security_boundaries:
    frontend_to_data: "BLOCKED - Frontend cannot directly access data layer"
    external_to_backend: "BLOCKED - Backend services not externally accessible"
    external_to_data: "BLOCKED - Data services completely isolated"

# =====================================================================
# SECURITY ENHANCEMENTS OVER OPEN RESEARCH
# Additional protections provided by network segmentation
# =====================================================================

security_improvements:
  
  network_isolation:
    description: "Services isolated by function and risk level"
    benefits:
      - "Compromised frontend cannot directly access databases"
      - "Data breaches limited to specific network segments"
      - "Easier to monitor and control inter-service communication"
      - "Simplified compliance through clear data flow boundaries"
  
  access_controls:
    description: "Network-level restrictions on service communication"
    implementation:
      - "Frontend services cannot bypass backend to reach data"
      - "Data services protected from direct external access"
      - "Backend services isolated from external attack surface"
  
  monitoring_advantages:
    description: "Network segmentation enables better security monitoring"
    capabilities:
      - "Monitor cross-network communication for anomalies"
      - "Separate logging for different security zones"
      - "Easier to detect lateral movement attacks"
      - "Clear audit trails for compliance reporting"

# =====================================================================
# OPERATIONAL CONSIDERATIONS
# How network segmentation affects day-to-day operations
# =====================================================================

operational_impact:
  
  service_discovery:
    description: "How services find each other across network boundaries"
    patterns:
      - "Use environment variables for cross-network service URLs"
      - "Implement service registration for dynamic discovery"
      - "Maintain DNS entries for critical service endpoints"
    example_configurations:
      # Backend service connecting to data layer:
      - "DATABASE_URL=postgresql://user:pass@postgresql.sushi_data:5432/db"
      # Frontend service connecting to backend:
      - "OLLAMA_API_URL=http://ollama.sushi_backend:11434"
  
  debugging_complexity:
    description: "Network segmentation adds troubleshooting complexity"
    considerations:
      - "Services may not be able to directly ping each other"
      - "Need to understand which networks each service uses"
      - "Cross-network communication requires proper routing"
    debugging_strategies:
      - "Use network-aware monitoring tools"
      - "Implement comprehensive health checks"
      - "Maintain network topology documentation"
  
  deployment_coordination:
    description: "Services must start in proper order across networks"
    requirements:
      - "Data services start first (databases, storage)"
      - "Backend services start second (processing, APIs)"  
      - "Frontend services start last (user interfaces)"
    automation_approaches:
      - "Use Docker Compose depends_on with health checks"
      - "Implement startup coordination in orchestration scripts"
      - "Monitor service readiness across all network tiers"

# =====================================================================
# MONITORING AND OBSERVABILITY
# How to maintain visibility across segmented networks
# =====================================================================

monitoring_strategy:
  
  network_monitoring:
    description: "Monitor health and performance of each network segment"
    metrics_to_track:
      - "Inter-network traffic volumes and patterns"
      - "Network latency between tiers"
      - "Failed connection attempts across boundaries"
      - "Bandwidth utilization per network segment"
  
  service_discovery_monitoring:
    description: "Ensure services can find each other across networks"
    health_checks:
      - "DNS resolution across network boundaries"
      - "Port accessibility between authorized service pairs"
      - "Authentication success rates for cross-tier calls"
      - "API response times across network hops"
  
  security_monitoring:
    description: "Detect potential security issues in network communication"
    alerting_criteria:
      - "Unexpected cross-network communication attempts"
      - "Services trying to access unauthorized network segments"
      - "Unusual traffic patterns between tiers"
      - "Failed authentication attempts across networks"

# =====================================================================
# COMPLIANCE AND AUDIT CAPABILITIES
# How network segmentation supports business compliance requirements
# =====================================================================

compliance_features:
  
  data_flow_control:
    description: "Clear boundaries for data movement and access"
    advantages:
      - "Data processing isolated from user access points"
      - "Storage systems protected from direct external access"
      - "Clear audit trail of data access patterns"
      - "Simplified compliance reporting for data handling"
  
  network_audit_logging:
    description: "Comprehensive logging of network communications"
    log_sources:
      - "Docker network driver logs"
      - "Service-to-service API call logs" 
      - "Authentication and authorization logs"
      - "Network access control violation logs"
  
  incident_response:
    description: "Network segmentation aids security incident response"
    capabilities:
      - "Isolate compromised services by network segment"
      - "Trace attack progression through network boundaries"
      - "Implement emergency network isolation procedures"
      - "Maintain service availability during incident response"

# =====================================================================
# MIGRATION AND EVOLUTION PATHS
# How to transition to/from this network profile
# =====================================================================

migration_guidance:
  
  from_open_research:
    description: "Upgrading from single network to segmented architecture"
    steps:
      - "Audit current service communication patterns"
      - "Assign services to appropriate network tiers"
      - "Update service configurations for new network hostnames"
      - "Test inter-service communication across network boundaries"
      - "Implement monitoring for new network architecture"
    
    common_challenges:
      - "Services hardcoded with simple hostnames"
      - "Applications assuming all services are directly reachable"
      - "Health checks that need cross-network access"
      - "Monitoring systems that need visibility across tiers"
  
  to_legal_privilege:
    description: "Further hardening for maximum security requirements"
    additional_requirements:
      - "Add audit logging network for compliance monitoring"
      - "Implement encryption for all inter-service communication"
      - "Add authentication for all cross-network API calls"
      - "Enable comprehensive network traffic logging"
      - "Implement data retention and purge capabilities"

# =====================================================================
# VALIDATION AND TESTING
# How to verify the network segmentation is working correctly
# =====================================================================

validation_procedures:
  
  network_connectivity_tests:
    description: "Verify services can reach authorized destinations"
    test_cases:
      # Positive tests (should work):
      - "Frontend service ‚Üí Backend service API"
      - "Backend service ‚Üí Data service database"
      - "Monitoring service ‚Üí Services in all tiers"
      
      # Negative tests (should fail):
      - "Frontend service ‚Üí Data service directly"
      - "External client ‚Üí Backend service directly"
      - "External client ‚Üí Data service directly"
  
  security_boundary_validation:
    description: "Confirm network isolation is effective"
    verification_methods:
      - "Attempt unauthorized cross-network connections"
      - "Verify data services are not externally accessible"
      - "Test that network failures don't cascade inappropriately"
      - "Confirm monitoring can detect unauthorized access attempts"
  
  operational_readiness_checks:
    description: "Ensure the segmented network supports business operations"
    success_criteria:
      - "All business workflows function correctly"
      - "Performance is acceptable across network boundaries"
      - "Monitoring provides adequate visibility"
      - "Incident response procedures work as designed"